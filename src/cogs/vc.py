"""A voice channel audio playback cog for JerryBot."""

import asyncio
import os
import subprocess
import sys
import discord
from discord.ext import commands
from discord import app_commands
import logging
from mutagen import File as MutagenFile
from mutagen.id3 import ID3NoHeaderError
from datetime import timedelta

from core import Bot, PermissionLevel

logger = logging.getLogger("jerry.vc")

DEFAULT_CONFIG = """# VoiceChannel Cog Configuration

# SpotDl Configuration
enabled: false
client_id: "your_client_id"
client_secret: "your_client_secret"
output_format: "mp3"
"""


class VoiceChannel(commands.Cog):
    def __init__(self, bot: Bot):
        self.bot = bot
        self.voice_clients = {}
        self.playlist_states = {}  # Track playlist state for each guild
        self.should_stop = {}  # Track if we should stop the entire playlist

        self.files = self.bot.filebroker.configure_cog(
            "VoiceChannel",
            cache=True,
            cache_clear_on_init=False,
            config_file=True,
            config_default=DEFAULT_CONFIG,
        )
        self.files.init()

        self.path = self.files.get_cache_dir()
        self.config: dict = self.files.get_config()

    async def cog_load(self):
        """Initialize resources when the cog is loaded."""

    @app_commands.command(
        name="vc-play", description="[Experimental] Play audio in the voice channel."
    )
    @app_commands.describe(
        url="Radio URL to stream audio from (e.g. from fmstream.org).",
        spot_id="ID generated by /vc-spotify to play imported songs from that import."
    )
    @app_commands.guild_install()
    async def vc_play(
        self, interaction: discord.Interaction, spot_id: str = None, url: str = None
    ):
        """Play an audio file in the voice channel. Automatically joins if not connected."""
        if not spot_id and not url:
            await interaction.response.send_message(
                "You must provide either a SpotDL ID or a URL to play audio from.",
                ephemeral=True,
            )
            return

        # Check if user is in a voice channel
        if not interaction.user.voice or not interaction.user.voice.channel:
            await interaction.response.send_message(
                "You are not in a voice channel.", ephemeral=True
            )
            return

        user_channel = interaction.user.voice.channel
        voice_client = None

        # Check if we're already connected to a voice channel
        if interaction.guild.id in self.voice_clients:
            voice_client = self.voice_clients[interaction.guild.id]

            # Check if we're in the same channel as the user
            if voice_client.channel != user_channel:
                await interaction.response.send_message(
                    f"This feature is currently limited to one voice channel at a time.",
                    ephemeral=True,
                )
                return
        else:
            # Join the user's voice channel
            if not user_channel.permissions_for(interaction.guild.me).connect:
                await interaction.response.send_message(
                    "I do not have permission to join your voice channel.",
                    ephemeral=True,
                )
                return

            try:
                voice_client = await user_channel.connect()
                self.voice_clients[interaction.guild.id] = voice_client
                logger.info(
                    f"Joined voice channel: {user_channel.name} in guild: {interaction.guild.name}"
                )
            except Exception as e:
                await interaction.response.send_message(
                    f"Failed to join the voice channel: {e}", ephemeral=True
                )
                logger.error(f"Attempt to join {user_channel.name} failed: {e}")
                return

        # Validate file path if provided
        if voice_client.is_playing():
            await interaction.response.send_message(
                "Already playing audio. Please wait until the current audio finishes, or use `/vc-stop` to stop it.",
                ephemeral=True,
            )
            return

        if spot_id:
            await interaction.response.send_message(
                f"Playing songs from SpotDL import ID: {spot_id}.", ephemeral=True
            )
            await self.play_spotdl(interaction, spot_id)
            return
        elif url:
            try:
                audio_source = discord.FFmpegPCMAudio(url, options="-vn")
                voice_client.play(
                    audio_source,
                    after=lambda e: logger.info(f"Finished playing: {e}") if e else None,
                )

                await interaction.response.send_message(
                    f"Now playing audio from URL in {voice_client.channel.name}.",
                    ephemeral=True,
                )
            except Exception as e:
                await interaction.response.send_message(
                    f"Failed to play audio from URL: {e}", ephemeral=True
                )
                return
            
    @app_commands.command(
        name="vc-stop",
        description="[Experimental] Stop audio playback completely in the voice channel.",
    )
    @app_commands.guild_install()
    async def vc_stop(self, interaction: discord.Interaction):
        """Stop audio playback completely in the voice channel."""
        if interaction.guild.id not in self.voice_clients:
            await interaction.response.send_message(
                "I am not connected to any voice channel.", ephemeral=True
            )
            return

        voice_client: discord.VoiceClient = self.voice_clients[interaction.guild.id]

        if not voice_client.is_playing():
            await interaction.response.send_message(
                "No audio is currently playing.", ephemeral=True
            )
            return

        try:
            # Set flag to stop the entire playlist
            self.should_stop[interaction.guild.id] = True
            
            # Stop current song
            voice_client.stop()
            
            # Clear playlist state
            if interaction.guild.id in self.playlist_states:
                del self.playlist_states[interaction.guild.id]
            
            await interaction.response.send_message(
                "Stopped audio playback completely.", ephemeral=True
            )
        except Exception as e:
            await interaction.response.send_message(
                f"Failed to stop audio playback: {e}", ephemeral=True
            )

    @app_commands.command(
        name="vc-skip",
        description="[Experimental] Skip the current song and play the next one.",
    )
    @app_commands.guild_install()
    async def vc_skip(self, interaction: discord.Interaction):
        """Skip the current song and continue to the next one."""
        if interaction.guild.id not in self.voice_clients:
            await interaction.response.send_message(
                "I am not connected to any voice channel.", ephemeral=True
            )
            return

        voice_client: discord.VoiceClient = self.voice_clients[interaction.guild.id]

        if not voice_client.is_playing():
            await interaction.response.send_message(
                "No audio is currently playing.", ephemeral=True
            )
            return

        try:
            # Don't set the stop flag, just skip to next song
            voice_client.stop()
            await interaction.response.send_message(
                "Skipped to the next song.", ephemeral=True
            )
        except Exception as e:
            await interaction.response.send_message(
                f"Failed to skip the song: {e}", ephemeral=True
            )

    @app_commands.command(
        name="vc-status",
        description="[Experimental] Show current playlist status and what's playing.",
    )
    @app_commands.guild_install()
    async def vc_status(self, interaction: discord.Interaction):
        """Show current playlist status."""
        guild_id = interaction.guild.id
        
        if guild_id not in self.voice_clients:
            await interaction.response.send_message(
                "I am not connected to any voice channel.", ephemeral=True
            )
            return

        voice_client: discord.VoiceClient = self.voice_clients[guild_id]
        
        if guild_id not in self.playlist_states:
            if voice_client.is_playing():
                await interaction.response.send_message(
                    "Currently playing audio from URL (not a playlist).", ephemeral=True
                )
            else:
                await interaction.response.send_message(
                    "No audio is currently playing.", ephemeral=True
                )
            return

        playlist_state = self.playlist_states[guild_id]
        current_index = playlist_state['current_index']
        total_files = len(playlist_state['files'])
        current_file = playlist_state['files'][current_index] if current_index < total_files else "Unknown"
        
        # Extract metadata for richer display
        metadata = None
        if current_index < total_files:
            file_path = os.path.join(playlist_state['directory'], current_file)
            try:
                metadata = self.extract_metadata(file_path)
            except Exception as e:
                logger.warning(f"Failed to extract metadata: {e}")
        
        embed = self.now_playing_toast_embed(
            metadata if metadata else self._get_fallback_metadata(current_file),
            current_index + 1,
            total_files
        )

    @app_commands.command(
        name="vc-leave", description="[Experimental] Leave the voice channel."
    )
    @app_commands.guild_install()
    async def vc_leave(self, interaction: discord.Interaction):
        """Leave the voice channel."""
        guild_id = interaction.guild.id
        
        if guild_id not in self.voice_clients:
            await interaction.response.send_message(
                "I am not connected to any voice channel.", ephemeral=True
            )
            return

        voice_client: discord.VoiceClient = self.voice_clients[guild_id]

        try:
            await voice_client.disconnect()
            del self.voice_clients[guild_id]
            
            # Clean up state tracking
            if guild_id in self.playlist_states:
                del self.playlist_states[guild_id]
            if guild_id in self.should_stop:
                del self.should_stop[guild_id]
                
            await interaction.response.send_message(
                "Disconnected from the voice channel.", ephemeral=True
            )
        except Exception as e:
            await interaction.response.send_message(
                f"Failed to leave the voice channel: {e}", ephemeral=True
            )

    def sanitize_path(self, path: str) -> str:
        """Sanitize a file path to prevent directory traversal and invalid characters."""
        # Remove any leading/trailing whitespace
        path = path.strip()

        # Replace spaces with underscores
        path = path.replace(" ", "_")

        # Remove any characters that are not alphanumeric, underscores, hyphens, or dots
        valid_chars = (
            "-_.()abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
        )
        sanitized = "".join(c for c in path if c in valid_chars)

        return sanitized
    
    def sanitize_url(self, url: str) -> str:
        """Sanitize a URL to prevent commands injection and invalid characters."""
        # Remove any leading/trailing whitespace
        url = url.strip()

        # Basic validation to ensure it looks like a URL
        if not (url.startswith("http://") or url.startswith("https://")):
            raise ValueError("Invalid URL format.")
        
        # Remove any characters that are not typically found in URLs
        valid_chars = (
            "-_.:/?&=abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
        )
        url = "".join(c for c in url if c in valid_chars)
        
        # Limit length to prevent abuse
        if len(url) > 2048:
            raise ValueError("URL is too long.")

        # Further sanitization can be added as needed
        return url

    def extract_metadata(self, file_path: str) -> dict:
        """Extract metadata from an audio file."""
        try:
            audio_file = MutagenFile(file_path)
            if audio_file is None:
                return self._get_fallback_metadata(file_path)

            metadata = {}
            
            # Common metadata fields
            metadata['title'] = self._get_tag(audio_file, ['TIT2', 'TITLE', '\xa9nam'])
            metadata['artist'] = self._get_tag(audio_file, ['TPE1', 'ARTIST', '\xa9ART'])
            metadata['album'] = self._get_tag(audio_file, ['TALB', 'ALBUM', '\xa9alb'])
            metadata['date'] = self._get_tag(audio_file, ['TDRC', 'DATE', '\xa9day'])
            metadata['genre'] = self._get_tag(audio_file, ['TCON', 'GENRE', '\xa9gen'])
            
            # Duration
            if hasattr(audio_file, 'info') and audio_file.info:
                duration_seconds = getattr(audio_file.info, 'length', 0)
                metadata['duration'] = str(timedelta(seconds=int(duration_seconds)))
                metadata['duration_seconds'] = int(duration_seconds)
            else:
                metadata['duration'] = "Unknown"
                metadata['duration_seconds'] = 0
            
            # Bitrate and sample rate
            if hasattr(audio_file, 'info') and audio_file.info:
                metadata['bitrate'] = getattr(audio_file.info, 'bitrate', 0)
                metadata['sample_rate'] = getattr(audio_file.info, 'sample_rate', 0)
            
            # File info
            metadata['file_name'] = os.path.basename(file_path)
            metadata['file_size'] = self._format_file_size(os.path.getsize(file_path))
            
            # Clean up empty values
            for key, value in metadata.items():
                if not value or (isinstance(value, str) and value.strip() == ""):
                    if key == 'title':
                        metadata[key] = os.path.splitext(os.path.basename(file_path))[0]
                    elif key in ['artist', 'album', 'genre']:
                        metadata[key] = "Unknown"
                    elif key == 'date':
                        metadata[key] = "Unknown"

            return metadata
            
        except (ID3NoHeaderError, Exception) as e:
            logger.warning(f"Could not extract metadata from {file_path}: {e}")
            return self._get_fallback_metadata(file_path)

    def _get_tag(self, audio_file, tag_names: list) -> str:
        """Get a tag value from multiple possible tag name formats."""
        for tag_name in tag_names:
            if tag_name in audio_file:
                tag_value = audio_file[tag_name]
                if isinstance(tag_value, list) and len(tag_value) > 0:
                    return str(tag_value[0])
                else:
                    return str(tag_value)
        return ""

    def _get_fallback_metadata(self, file_path: str) -> dict:
        """Generate fallback metadata when extraction fails."""
        file_name = os.path.basename(file_path)
        title = os.path.splitext(file_name)[0]
        
        return {
            'title': title,
            'artist': "Unknown",
            'album': "Unknown",
            'date': "Unknown",
            'genre': "Unknown",
            'duration': "Unknown",
            'duration_seconds': 0,
            'bitrate': 0,
            'sample_rate': 0,
            'file_name': file_name,
            'file_size': self._format_file_size(os.path.getsize(file_path))
        }

    def _format_file_size(self, size_bytes: int) -> str:
        """Format file size in human-readable format."""
        if size_bytes < 1024:
            return f"{size_bytes} B"
        elif size_bytes < 1024 * 1024:
            return f"{size_bytes / 1024:.1f} KB"
        elif size_bytes < 1024 * 1024 * 1024:
            return f"{size_bytes / (1024 * 1024):.1f} MB"
        else:
            return f"{size_bytes / (1024 * 1024 * 1024):.1f} GB"

    def now_playing_toast_embed(self, metadata: dict, progress_current: int, progress_total: int) -> discord.Embed:
        """Create a Discord embed for now playing toast."""
        embed = discord.Embed(
            title=metadata['title'],
            description=f"by {metadata['artist']}",
            color=discord.Color.blurple()
        )
        embed.set_author(name="ðŸŽµ Now Playing")
        # embed.add_field(name="Album", value=metadata['album'], inline=True)
        embed.set_footer(text=f"{metadata['duration']} | {progress_current}/{progress_total}")

        return embed

    @app_commands.command(
        name="vc-metadata",
        description="[Experimental] Show metadata for the currently playing song.",
    )
    @app_commands.guild_install()
    async def vc_metadata(self, interaction: discord.Interaction):
        """Show detailed metadata for the currently playing song."""
        guild_id = interaction.guild.id
        
        if guild_id not in self.voice_clients:
            await interaction.response.send_message(
                "I am not connected to any voice channel.", ephemeral=True
            )
            return

        if guild_id not in self.playlist_states:
            await interaction.response.send_message(
                "No playlist is currently active.", ephemeral=True
            )
            return

        playlist_state = self.playlist_states[guild_id]
        current_index = playlist_state['current_index']
        
        if current_index >= len(playlist_state['files']):
            await interaction.response.send_message(
                "No valid song is currently selected.", ephemeral=True
            )
            return

        current_file = playlist_state['files'][current_index]
        file_path = os.path.join(playlist_state['directory'], current_file)
        
        # Extract metadata
        metadata = self.extract_metadata(file_path)
        
        # Create detailed embed
        embed = discord.Embed(
            title="ðŸŽµ Song Metadata",
            color=discord.Color.blue()
        )
        
        embed.add_field(name="ðŸ“€ Title", value=metadata['title'], inline=False)
        embed.add_field(name="ðŸŽ¤ Artist", value=metadata['artist'], inline=True)
        embed.add_field(name="ðŸ’¿ Album", value=metadata['album'], inline=True)
        embed.add_field(name="ðŸ“… Date", value=metadata['date'], inline=True)
        embed.add_field(name="ðŸŽ­ Genre", value=metadata['genre'], inline=True)
        embed.add_field(name="â±ï¸ Duration", value=metadata['duration'], inline=True)
        embed.add_field(name="ðŸ“Š Quality", value=f"{metadata['bitrate']} kbps" if metadata['bitrate'] > 0 else "Unknown", inline=True)
        embed.add_field(name="ðŸ“ File", value=metadata['file_name'], inline=False)
        embed.add_field(name="ðŸ’¾ Size", value=metadata['file_size'], inline=True)
        
        if metadata['sample_rate'] > 0:
            embed.add_field(name="ðŸ”Š Sample Rate", value=f"{metadata['sample_rate']} Hz", inline=True)
        
        await interaction.response.send_message(embed=embed, ephemeral=True)

    @app_commands.command(
        name="vc-spotify",
        description="[Experimental] Import songs from Spotify using spotdl.",
    )
    @app_commands.describe(
        url="The Spotify URL (track, album, playlist) to import songs from.",
        id="An identifier used to recall this import later.",
    )
    async def vc_spotdl_import(
        self, interaction: discord.Interaction, url: str, id: str
    ):
        """Import songs using spotdl."""
        if (
            await self.bot.permissions.interaction_check(
                interaction, PermissionLevel.APPROVED
            )
            is False
        ):
            return

        await interaction.response.send_message(
            "",
            ephemeral=True,
            embed=discord.Embed(
                title="SpotDL Import | In Progress",
                description="Starting import process, please wait... \n(this may take a while depending on the number of songs)",
            ),
        )
        try:
            output = await self.spotdl_import(url, id)
            log_output = "\n".join(output[-10:])
            # Truncate log_output to fit within Discord's 1024 character limit for field values, with buffer.
            if len(log_output) > 1000:
                log_output = log_output[-1000:] + "..."

            await interaction.edit_original_response(
                content="",
                embed=discord.Embed(
                    title="SpotDL Import | Success",
                    description=f"Successfully imported songs from `{url}`.\nAccess the import using ID: `{id}` To play, use `/vc-play` with the spot_id parameter.",
                    color=discord.Color.green(),
                ).add_field(name="Logs", value=f"```\n{log_output}\n```" if output else "No log output available.")
            )
        except Exception as e:
            await interaction.edit_original_response(
                content="",
                embed=discord.Embed(
                    title="SpotDL Failed",
                    description=str(e),
                    color=discord.Color.red(),
                ),
            )

    async def spotdl_import(self, url: str, dir: str) -> list[str]:
        """Import songs using spotdl. Returns log output as a list of strings."""
        output = []

        # Config
        if self.spotdl_client is None:
            raise RuntimeError("SpotDl integration is disabled.")

        # Determine target directory
        dir = dir
        sanitized_dir = self.sanitize_path(dir)
        host_dir = self.config.get("path", self.path)
        target_dir = os.path.join(host_dir, sanitized_dir)

        logger.info(f"Importing songs from {url} to {target_dir}")
        output.append(f"Importing songs from {url} to {sanitized_dir}")

        # Ensure target directory exists
        os.makedirs(target_dir, exist_ok=True)
        
        # Sanitize URL
        try:
            url = self.sanitize_url(url)
        except ValueError as ve:
            raise ValueError(f"Invalid URL: {ve}")

        # Execute search - this is synchronous in spotdl
        output.append(f"Searching for songs from {url}...")
        try:
            # Skipped cuz it's built into the download process
            # # First, search for songs (this is synchronous and safe)
            loop = asyncio.get_running_loop()
            # songs = await loop.run_in_executor(
            #     None, 
            #     self.spotdl_client.search,
            #     [url]
            # )
            
            # if not songs:
            #     raise ValueError("No songs found for the provided URL.")
                
            # output.append(f"Found {len(songs)} songs.")
            
            # Download songs using spotdl CLI via subprocess
            
            def run_spotdl_download():
                # Build the spotdl command
                cmd = [
                    sys.executable, "-m", "spotdl",
                    "download", url,
                    # "--output", target_dir, # Already set by cwd
                    "--format", self.config.get("output_format", "mp3")
                ]
                
                # Set environment variables for Spotify credentials
                env = os.environ.copy()
                env["SPOTIPY_CLIENT_ID"] = self.config.get("client_id")
                env["SPOTIPY_CLIENT_SECRET"] = self.config.get("client_secret")
                
                result = subprocess.run(
                    cmd,
                    capture_output=True,
                    text=True,
                    env=env,
                    cwd=target_dir
                )
                
                if result.returncode != 0:
                    raise RuntimeError(f"SpotDL download failed: {result.stderr}")
                
                return result.stdout
            
            # Run the download in executor
            download_output = await loop.run_in_executor(None, run_spotdl_download)
            output.append(download_output)
            
        except Exception as e:
            logger.error(f"SpotDL operation failed: {e}")
            raise RuntimeError(f"SpotDL operation failed: {e}")

        output.append(f"Downloaded songs to {target_dir}")

        return output

    async def play_spotdl(self, interaction: discord.Interaction, id: str):
        """Play songs from a spotdl import."""
        if interaction.guild.id not in self.voice_clients:
            await interaction.response.followup.send(
                "I am not connected to any voice channel. Please use `/vc-play` with a SpotDL ID or URL first.",
                ephemeral=True,
            )
            return
        
        # Validate ID
        if not id or not isinstance(id, str):
            await interaction.response.followup.send(
                "You must provide a valid SpotDL ID to play songs from.",
                ephemeral=True,
            )
            return
        
        # Fetch songs from the specified directory
        sanitized_id = self.sanitize_path(id)
        host_dir = self.config.get("path", self.path)
        target_dir = os.path.join(host_dir, sanitized_id)

        if not os.path.exists(target_dir):
            await interaction.response.followup.send(
                "No songs found for the provided SpotDL ID.",
                ephemeral=True,
            )
            return

        # Play the songs using the voice client
        voice_client = self.voice_clients[interaction.guild.id]
        
        await self.play_directory(voice_client, target_dir)
        
    async def play_directory(self, voice_client: discord.VoiceClient, directory: str):
        """Play all audio files in a directory sequentially."""
        if not os.path.isdir(directory):
            raise ValueError("Provided path is not a directory.")

        # List all audio files in the directory
        audio_files = [
            f for f in os.listdir(directory)
            if os.path.isfile(os.path.join(directory, f)) and f.lower().endswith(('.mp3', '.wav', '.ogg', '.flac'))
        ]

        if not audio_files:
            raise ValueError("No audio files found in the specified directory.")

        guild_id = voice_client.guild.id
        channel = voice_client.channel
        
        # Store playlist state before starting the loop
        self.playlist_states[guild_id] = {
            'directory': directory,
            'files': audio_files,
            'current_index': 0
        }
        
        # Reset stop flag
        self.should_stop[guild_id] = False

        try:
            for i, audio_file in enumerate(audio_files):
                # Check if we should stop the entire playlist
                if self.should_stop.get(guild_id, False):
                    logger.info(f"Playlist stopped by user in guild {guild_id}")
                    break
                    
                # Update current index - ensure the state still exists
                if guild_id in self.playlist_states:
                    self.playlist_states[guild_id]['current_index'] = i
                
                file_path = os.path.join(directory, audio_file)
                audio_source = discord.FFmpegPCMAudio(file_path)

                logger.info(f"Now playing: {audio_file}")
                
                # Toast notification (if interaction is available)
                embed = self.now_playing_toast_embed(
                    self.extract_metadata(file_path),
                    i + 1,
                    len(audio_files)
                )
                try:
                    await channel.send(embed=embed)
                except Exception as e:
                    logger.warning(f"Failed to send now playing toast: {e}")
                
                # Extract metadata and send toast (optional - you can enable/disable this)
                try:
                    metadata = self.extract_metadata(file_path)
                    # You could send this to a specific channel or use interaction if available
                    # For now, we'll log the metadata
                    logger.info(f"Playing: {metadata['artist']} - {metadata['title']} ({metadata['duration']})")
                except Exception as e:
                    logger.warning(f"Failed to extract metadata for {audio_file}: {e}")

                # Play the audio file
                voice_client.play(
                    audio_source,
                    after=lambda e: logger.info(f"Finished playing {audio_file}: {e}") if e else None,
                )

                # Wait until the current audio finishes playing
                while voice_client.is_playing():
                    # Check if we should stop during playback
                    if self.should_stop.get(guild_id, False):
                        voice_client.stop()
                        break
                    await asyncio.sleep(1)
                    
        finally:
            # Clean up playlist state when done
            if guild_id in self.playlist_states:
                del self.playlist_states[guild_id]
            if guild_id in self.should_stop:
                del self.should_stop[guild_id]